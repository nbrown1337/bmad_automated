---
phase: 01-sprint-status-reader
plan: 01
type: execute
---

<objective>
Create the `internal/status` package that reads `sprint-status.yaml` and returns story statuses by key.

Purpose: Foundation for status-based workflow routing - all subsequent phases depend on this.
Output: Working `status` package with types, reader, and tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Existing patterns to follow:**
@internal/config/types.go - Type definition pattern
@internal/config/config.go - File loading pattern (Viper not needed here, direct yaml.v3)
@internal/config/config_test.go - Test patterns (table-driven, temp files, require/assert)

**Sprint status file format:**

- Location: `_bmad-output/implementation-artifacts/sprint-status.yaml`
- Contains `development_status` section with story keys and statuses
- Story keys: `{epic#}-{story#}-{description}` (e.g., `7-1-define-schema`)
- Statuses: `backlog`, `ready-for-dev`, `in-progress`, `review`, `done`

**Example sprint-status.yaml structure:**

```yaml
development_status:
  7-1-define-schema: ready-for-dev
  7-2-create-api: backlog
  7-3-build-ui: backlog
```

**Workflow mapping (for context - used in Phase 2):**
| Status | Workflow |
|--------|----------|
| `backlog` | create-story |
| `ready-for-dev` | dev-story |
| `in-progress` | dev-story |
| `review` | code-review |
| `done` | (skip) |
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create status package types</name>
  <files>internal/status/types.go</files>
  <action>
Create `internal/status/` directory and `types.go` with:

1. Package doc comment: "Package status provides functionality for reading sprint status from YAML files."

2. `Status` type - string alias with constants:
   - StatusBacklog = "backlog"
   - StatusReadyForDev = "ready-for-dev"
   - StatusInProgress = "in-progress"
   - StatusReview = "review"
   - StatusDone = "done"

3. `SprintStatus` struct for YAML parsing:
   - `DevelopmentStatus map[string]Status` with yaml tag `development_status`

4. `IsValid()` method on Status type that returns true for known status values.

Follow existing naming conventions from internal/config/types.go (PascalCase, no prefix on types).
</action>
<verify>go build ./internal/status/... compiles without errors</verify>
<done>types.go exists with Status type, constants, SprintStatus struct, and IsValid method</done>
</task>

<task type="auto">
  <name>Task 2: Implement status reader</name>
  <files>internal/status/reader.go</files>
  <action>
Create `reader.go` with:

1. `Reader` struct with `basePath string` field (base directory to look for sprint-status.yaml)

2. `NewReader(basePath string) *Reader` constructor

3. `DefaultStatusPath` constant = `_bmad-output/implementation-artifacts/sprint-status.yaml`

4. `Read() (*SprintStatus, error)` method:
   - Construct full path: filepath.Join(r.basePath, DefaultStatusPath)
   - Read file with os.ReadFile
   - Parse with yaml.Unmarshal into SprintStatus
   - Return pointer to parsed struct
   - Wrap errors with context: "failed to read sprint status: %w"

5. `GetStoryStatus(storyKey string) (Status, error)` method:
   - Call Read() to get SprintStatus
   - Look up storyKey in DevelopmentStatus map
   - Return status if found
   - Return error "story not found: {storyKey}" if not in map

Use gopkg.in/yaml.v3 (already in go.mod as transitive dependency).

Do NOT use Viper - direct yaml.v3 is simpler for a single file with known structure.
</action>
<verify>go build ./internal/status/... compiles without errors</verify>
<done>reader.go exists with Reader struct, NewReader, Read, and GetStoryStatus methods</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests</name>
  <files>internal/status/reader_test.go, internal/status/types_test.go</files>
  <action>
Create test files following patterns from internal/config/config_test.go:

**types_test.go:**

- TestStatus_IsValid - table-driven test for all status constants (valid) and unknown strings (invalid)
- TestStatus_Constants - verify constant values match expected strings

**reader_test.go:**

- TestNewReader - verify constructor creates reader with basePath
- TestReader_Read_Success - create temp dir with valid sprint-status.yaml, verify parsing
- TestReader_Read_FileNotFound - verify error when file doesn't exist
- TestReader_Read_InvalidYAML - verify error on malformed YAML
- TestReader_GetStoryStatus_Found - verify returns correct status for existing story
- TestReader_GetStoryStatus_NotFound - verify error for non-existent story key
- TestReader_GetStoryStatus_MultipleStories - verify can read multiple stories from same file

Use:

- t.TempDir() for temp directories (auto-cleaned)
- require.NoError for fatal setup errors
- assert for non-fatal assertions
- Table-driven tests where multiple cases share structure

Test YAML content example:

```yaml
development_status:
  7-1-define-schema: ready-for-dev
  7-2-create-api: in-progress
  7-3-build-ui: backlog
```

  </action>
  <verify>just test-pkg ./internal/status passes all tests</verify>
  <done>All tests pass, coverage includes success paths, error paths, and edge cases</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `just test` passes all tests including new status package
- [ ] `just lint` passes without errors
- [ ] Reader can parse a real sprint-status.yaml format
- [ ] GetStoryStatus returns correct status for valid keys
- [ ] GetStoryStatus returns error for invalid keys
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No new linter warnings
- Package follows existing codebase conventions (naming, error handling, test patterns)
- Reader correctly parses sprint-status.yaml format
  </success_criteria>

<output>
After completion, create `.planning/phases/01-sprint-status-reader/01-01-SUMMARY.md`
</output>
