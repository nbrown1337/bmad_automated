---
phase: 04-update-queue-command
plan: 01
type: execute
---

<objective>
Update queue command to use status-based routing for each story in the queue.

Purpose: Apply the same automatic workflow routing from Phase 3 to the queue command, so each queued story runs its appropriate workflow based on status.
Output: Queue command that routes each story to create-story, dev-story, or code-review based on sprint-status.yaml.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (dependency chain):

@.planning/phases/01-sprint-status-reader/01-01-SUMMARY.md
@.planning/phases/02-workflow-router/02-01-SUMMARY.md
@.planning/phases/03-update-run-command/03-01-SUMMARY.md

# Key source files:

@internal/cli/queue.go
@internal/workflow/queue.go
@internal/cli/run.go
@internal/cli/run_test.go

**Tech stack available:**

- status.Reader for reading sprint-status.yaml
- router.GetWorkflow for status-to-workflow mapping
- App.StatusReader injection pattern (from Phase 3)

**Established patterns:**

- StatusReader injected via App struct (see run.go)
- Error handling: status errors → exit 1, done → success with message
- Sentinel error handling with errors.Is() for ErrStoryComplete, ErrUnknownStatus

**Constraining decisions:**

- Phase 3: StatusReader injected via App struct
- Phase 2: Sentinel errors for done and unknown status
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Update queue command to use status-based routing</name>
  <files>internal/cli/queue.go, internal/workflow/queue.go</files>
  <action>
Update queue command to route each story via status instead of running fixed full cycle:

1. In queue.go, update command description to reflect new behavior:
   - Short: "Run appropriate workflow for multiple stories based on status"
   - Long: Same status routing description as run command, but for multiple stories

2. Change queue.go RunE to pass StatusReader to QueueRunner:
   - Call a new method like `app.Queue.RunQueueWithStatus(ctx, args, app.StatusReader)`
   - OR pass StatusReader to QueueRunner at construction time in root.go

3. In workflow/queue.go, update RunQueue to use status-based routing:
   - For each story: get status via StatusReader.GetStoryStatus(storyKey)
   - Route via router.GetWorkflow(status)
   - If ErrStoryComplete: print skip message, continue to next story (not a failure)
   - If ErrUnknownStatus or status read error: fail immediately
   - Run workflow via runner.RunSingle(ctx, workflowName, storyKey)
   - Stop on first workflow failure (existing behavior)

4. Remove runFullCycleInternal method - no longer needed since we route per-story.

Key behavior difference from run command:

- Done stories in queue are SKIPPED (continue to next), not terminal success
- This allows `bmad-automate queue story-1 story-2 story-3` where some may be done
  </action>
  <verify>go build ./... compiles without errors</verify>
  <done>Queue command routes each story to appropriate workflow based on status, skips done stories, stops on first failure</done>
  </task>

<task type="auto">
  <name>Task 2: Add tests for queue status-based routing</name>
  <files>internal/cli/queue_test.go</files>
  <action>
Create queue_test.go with tests for status-based routing (parallel to run_test.go structure):

1. Create setupQueueTestApp helper (reuse pattern from run_test.go)

2. Test cases for TestQueueCommand_StatusBasedRouting:
   - Single story with backlog → runs create-story
   - Single story with ready-for-dev → runs dev-story
   - Single story with in-progress → runs dev-story
   - Single story with review → runs code-review
   - Single story with done → skips (no workflow executed, continues)
   - Multiple stories with mixed statuses → each routes correctly
   - Story not found → returns error

3. Test cases for queue-specific behavior:
   - TestQueueCommand_DoneStorySkipped: done story in queue is skipped, not failed
   - TestQueueCommand_StopsOnFailure: if workflow fails, queue stops immediately
   - TestQueueCommand_MixedStatusQueue: queue of [backlog, done, ready-for-dev] runs first, skips second, runs third

4. Test for missing sprint-status.yaml file → error

Use table-driven tests like run_test.go. Mock executor with success events.
</action>
<verify>go test ./internal/cli/... -run Queue -v passes</verify>
<done>Queue command has comprehensive test coverage for status-based routing including skip behavior for done stories</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./...` passes all tests
- [ ] `golangci-lint run` passes
- [ ] Queue command routes stories by status in manual testing
</verification>

<success_criteria>

- All tasks completed
- Queue command reads status for each story and routes appropriately
- Done stories are skipped (not failures) in queue
- Queue stops on first workflow failure
- Tests cover all routing cases and skip behavior
- No lint errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-update-queue-command/04-01-SUMMARY.md` following the summary template.
</output>
